<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何得到一个空的Hadoop Configuration</title>
    <url>/2020/07/11/hadoop-empty-configuration/</url>
    <content><![CDATA[<p>都怪JDK， <code>File</code>类的<code>delete()</code>方法竟然不能删除非空的目录。所以，我就想用Hadoop的API，于是有了下面一段程序</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> fileSystem = <span class="type">FileSystem</span>.newInstance(<span class="keyword">new</span> <span class="type">Configuration</span>())</span><br><span class="line"><span class="keyword">val</span> warehousePath = <span class="keyword">new</span> <span class="type">Path</span>(<span class="string">"spark-warehouse"</span>)</span><br><span class="line"><span class="keyword">if</span>(fileSystem.exists(warehousePath))</span><br><span class="line">  fileSystem.delete(warehousePath, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> metastoreDB = <span class="keyword">new</span> <span class="type">Path</span>(<span class="string">"metastore_db"</span>)</span><br><span class="line"><span class="keyword">if</span> (fileSystem.exists(metastoreDB))</span><br><span class="line">  fileSystem.delete(metastoreDB)</span><br></pre></td></tr></table></figure>

<p>问题是，<code>new Configuration()</code>默认会从classpath里找到<code>core-site.xml</code>和<code>core-default.xml</code>来加载，所以我想，万一以后不小心把这些文件加到classpath里呢？比如哪天我想要测试连接别的机器上的HDFS。还好，<code>Configuration</code>类有个方法来禁止对这俩文件的加载， 正如这个类的注释所说的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unless explicitly turned off, Hadoop by default specifies two resources, loaded in-order from the classpath:</span><br><span class="line"></span><br><span class="line">1. &#96;core-default.xml&#96;: Read-only defaults for hadoop.</span><br><span class="line">2. &#96;core-site.xml&#96;: Site-specific configuration for a given hadoop installation.</span><br></pre></td></tr></table></figure>

<p>我搞了个<code>core-site.xml</code>到classpath下，于是这段代码就会报错说</p>
<figure class="highlight plain"><figcaption><span>in thread "main" java.lang.IllegalArgumentException: java.net.UnknownHostException: cdh</span></figcaption><table><tr><td class="code"><pre><span class="line">	at org.apache.hadoop.security.SecurityUtil.buildTokenService(SecurityUtil.java:378)</span><br><span class="line">	at org.apache.hadoop.hdfs.NameNodeProxies.createNonHAProxy(NameNodeProxies.java:320)</span><br><span class="line">	at org.apache.hadoop.hdfs.NameNodeProxies.createProxy(NameNodeProxies.java:176)</span><br><span class="line">	at org.apache.hadoop.hdfs.DFSClient.&lt;init&gt;(DFSClient.java:678)</span><br><span class="line">	at org.apache.hadoop.hdfs.DFSClient.&lt;init&gt;(DFSClient.java:619)</span><br><span class="line">	at org.apache.hadoop.hdfs.DistributedFileSystem.initialize(DistributedFileSystem.java:149)</span><br><span class="line">	at org.apache.hadoop.fs.FileSystem.createFileSystem(FileSystem.java:2669)</span><br><span class="line">	at org.apache.hadoop.fs.FileSystem.access$200(FileSystem.java:94)</span><br><span class="line">	at org.apache.hadoop.fs.FileSystem$Cache.getInternal(FileSystem.java:2703)</span><br><span class="line">	at org.apache.hadoop.fs.FileSystem$Cache.getUnique(FileSystem.java:2691)</span><br><span class="line">	at org.apache.hadoop.fs.FileSystem.newInstance(FileSystem.java:420)</span><br><span class="line">	at org.apache.hadoop.fs.FileSystem.newInstance(FileSystem.java:428)</span><br><span class="line">	at sleepy.spark.SparkHiveExample$.main(SparkHiveExample.scala:45)</span><br><span class="line">	at sleepy.spark.SparkHiveExample.main(SparkHiveExample.scala)</span><br><span class="line">Caused by: java.net.UnknownHostException: cdh</span><br><span class="line">	... 14 more</span><br></pre></td></tr></table></figure>



<p>看起来程序去连接外部的HDFS时，发现无法识别<code>cdh</code>， 实际上它也并非是域名，而是<code>dfs.nameservices</code>的值。</p>
<p>好的，那就用<code>Configuration(boolean)</code>这个构造器, 这的文档是这样说的</p>
<blockquote>
<p>A new configuration where the behavior of reading from the default resources can be turned off. If the parameter <code>loadDefaults</code> is false, the new instance will not load resources from the default files.  </p>
</blockquote>
<p>但是呢，执行的时候仍然在报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.io.IOException: failure to login</span><br><span class="line">	at org.apache.hadoop.security.UserGroupInformation.loginUserFromSubject(UserGroupInformation.java:841)</span><br><span class="line">	at org.apache.hadoop.security.UserGroupInformation.getLoginUser(UserGroupInformation.java:777)</span><br><span class="line">	at org.apache.hadoop.security.UserGroupInformation.getCurrentUser(UserGroupInformation.java:650)</span><br><span class="line">	at org.apache.hadoop.fs.FileSystem$Cache$Key.&lt;init&gt;(FileSystem.java:2828)</span><br><span class="line">	at org.apache.hadoop.fs.FileSystem$Cache.getUnique(FileSystem.java:2690)</span><br><span class="line">	at org.apache.hadoop.fs.FileSystem.newInstance(FileSystem.java:420)</span><br><span class="line">	at org.apache.hadoop.fs.FileSystem.newInstance(FileSystem.java:428)</span><br><span class="line">	at sleepy.spark.SparkHiveExample$.main(SparkHiveExample.scala:47)</span><br><span class="line">	at sleepy.spark.SparkHiveExample.main(SparkHiveExample.scala)</span><br><span class="line">Caused by: javax.security.auth.login.LoginException: java.lang.IllegalArgumentException: Illegal principal name foo@FOO.COM: org.apache.hadoop.security.authentication.util.KerberosName$NoMatchingRule: No rules applied to foo@FOO.COM</span><br><span class="line">	at org.apache.hadoop.security.UserGroupInformation$HadoopLoginModule.commit(UserGroupInformation.java:201)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">	at javax.security.auth.login.LoginContext.invoke(LoginContext.java:755)</span><br><span class="line">	at javax.security.auth.login.LoginContext.access$000(LoginContext.java:195)</span><br><span class="line">	at javax.security.auth.login.LoginContext$4.run(LoginContext.java:682)</span><br><span class="line">	at javax.security.auth.login.LoginContext$4.run(LoginContext.java:680)</span><br><span class="line">	at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">	at javax.security.auth.login.LoginContext.invokePriv(LoginContext.java:680)</span><br><span class="line">	at javax.security.auth.login.LoginContext.login(LoginContext.java:588)</span><br><span class="line">	at org.apache.hadoop.security.UserGroupInformation.loginUserFromSubject(UserGroupInformation.java:815)</span><br><span class="line">	... 8 more</span><br><span class="line">Caused by: java.lang.IllegalArgumentException: Illegal principal name foo@FOO: org.apache.hadoop.security.authentication.util.KerberosName$NoMatchingRule: No rules applied to foo@FOO</span><br><span class="line">	at org.apache.hadoop.security.User.&lt;init&gt;(User.java:51)</span><br><span class="line">	at org.apache.hadoop.security.User.&lt;init&gt;(User.java:43)</span><br><span class="line">	at org.apache.hadoop.security.UserGroupInformation$HadoopLoginModule.commit(UserGroupInformation.java:199)</span><br><span class="line">	... 20 more</span><br><span class="line">Caused by: org.apache.hadoop.security.authentication.util.KerberosName$NoMatchingRule: No rules applied to foo@FOO</span><br><span class="line">	at org.apache.hadoop.security.authentication.util.KerberosName.getShortName(KerberosName.java:400)</span><br><span class="line">	at org.apache.hadoop.security.User.&lt;init&gt;(User.java:48)</span><br><span class="line">	... 22 more</span><br></pre></td></tr></table></figure>



<p>究其原因是在初始化<code>FileSystem</code>的时候，化调用到<code>UserGroupInformation#ensureIntialized()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensureInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (conf == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(UserGroupInformation<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (conf == <span class="keyword">null</span>) &#123; <span class="comment">// someone might have beat us</span></span><br><span class="line">        initialize(<span class="keyword">new</span> Configuration(), <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接调用了<code>new Configuration</code>,  而这个对象是加载了classpath里的配置文件的。</p>
<p>所以，直接给UGI指定个configuration就行了</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">Configuration</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="type">UserGroupInformation</span>.setConfiguration(conf)</span><br><span class="line"><span class="keyword">val</span> fileSystem = <span class="type">FileSystem</span>.newInstance(conf)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>mio::poll文档 —— 翻译和注解</title>
    <url>/2018/06/07/mio_poll/</url>
    <content><![CDATA[<p>翻译自<a href="https://docs.rs/mio/0.6.14/mio/struct.Poll.html">mio文档: Poll</a></p>
<h1 id="Struct-mio-Poll"><a href="#Struct-mio-Poll" class="headerlink" title="Struct mio::Poll"></a>Struct mio::Poll</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Poll</span></span> &#123; <span class="comment">/* fields omitted */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>Polls for readiness events on all registered values.</p>
<p>Poll allows a program to monitor a large number of Evented types, waiting until one or more become “ready” for some class of operations; e.g. reading and writing. An Evented type is considered ready if it is possible to immediately perform a corresponding operation; e.g. read or write.</p>
<p>To use Poll, an Evented type must first be registered with the Poll instance using the register method, supplying readiness interest. The readiness interest tells Poll which specific operations on the handle to monitor for readiness. A Token is also passed to the register function. When Poll returns a readiness event, it will include this token. This associates the event with the Evented handle that generated the event.</p>
<p>Poll用于从所有注册的value里poll处于就绪状态的事件。这个跟Java里NIO里的概念可以类比下：</p>
<ul>
<li>Selector &lt;-&gt; Poll。可以把Evented注册到Poll上，使用它来监听Evented有关的IO事件。是实现异步IO的关键组件。</li>
<li>Evented &lt;-&gt; SelectionKey。可以通过SelectionKey获取底层的channel进行读写。Evented可以直接进行读写。</li>
<li>Token &lt;-&gt; SelectionKey里attach的对象。用于将事件跟Evented关联起来。</li>
</ul>
<a id="more"></a>

<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><hr>
<p>一个基础的例子，创建一个TcpStream连接。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mio::&#123;Events, Poll, Ready, PollOpt, Token&#125;;</span><br><span class="line"><span class="keyword">use</span> mio::net::TcpStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::net::&#123;TcpListener, SocketAddr&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个server socket, 绑定到指定地址</span></span><br><span class="line"><span class="keyword">let</span> addr: SocketAddr = <span class="string">"127.0.0.1:0"</span>.parse()?;</span><br><span class="line"><span class="keyword">let</span> server = TcpListener::bind(&amp;addr)?;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Construct a new `Poll` handle as well as the `Events` we'll store into</span></span><br><span class="line"><span class="keyword">let</span> poll = Poll::new()?;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> events = Events::with_capacity(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect the stream</span></span><br><span class="line"><span class="keyword">let</span> stream = TcpStream::connect(&amp;server.local_addr()?)?;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把stream注册到`Poll`</span></span><br><span class="line">poll.register(&amp;stream, Token(<span class="number">0</span>), Ready::readable() | Ready::writable(), PollOpt::edge())?;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for the socket to become ready. This has to happens in a loop to</span></span><br><span class="line"><span class="comment">// handle spurious wakeups.</span></span><br><span class="line"><span class="comment">//等待socket可用。需要在一个处理虚假的wakeup的循环里做这件事</span></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    poll.poll(&amp;<span class="keyword">mut</span> events, <span class="literal">None</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> &amp;events &#123;</span><br><span class="line">        <span class="keyword">if</span> event.token() == Token(<span class="number">0</span>) &amp;&amp; event.readiness().is_writable() &#123;</span><br><span class="line">            <span class="comment">// The socket connected (probably, it could still be a spurious</span></span><br><span class="line">            <span class="comment">// wakeup)</span></span><br><span class="line">            <span class="comment">// socket连接上了(只是可能连接上了，仍然可能是一个假的wakeup)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">Ok</span>(());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Events-with-capacity"><a href="#Events-with-capacity" class="headerlink" title="Events::with_capacity"></a>Events::with_capacity</h2><p>在poll的源码的注释里写到</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// The supplied `events` will be cleared and newly received readiness events</span></span><br><span class="line"><span class="comment">/// will be pushed onto the end. At most `events.capacity()` events will be</span></span><br><span class="line"><span class="comment">/// returned. If there are further pending readiness events, they will be</span></span><br><span class="line"><span class="comment">/// returned on the next call to `poll`.</span></span><br></pre></td></tr></table></figure>

<h1 id="Edge-triggered-and-level-triggered"><a href="#Edge-triggered-and-level-triggered" class="headerlink" title="Edge-triggered and level-triggered"></a>Edge-triggered and level-triggered</h1><hr>
<p>问题在于，对于已经处于就绪状态的key，如果我们在poll返回的集合里没有对它进行操作, 例如没有读写，那么<br>下一次poll的时候，它还会在集合里吗？</p>
<h2 id="Java-NIO-的作法"><a href="#Java-NIO-的作法" class="headerlink" title="Java NIO 的作法"></a>Java NIO 的作法</h2><p>Java NIO的<code>Selector</code>维持了三个集合:</p>
<ul>
<li>key set。包含了所有注册到selector的channel对应的key</li>
<li>selected-key set。在这个集合中的key对应的channel处于readiness状态。</li>
<li>cancelled-key set。这些key已经被cancel，但是相关的channel还没有被deregistered。</li>
</ul>
<blockquote>
<p>Keys are added to the selected-key set by selection operations. A key may be removed directly from the selected-key set by invoking the set’s remove method or by invoking the remove method of an iterator obtained from the set. Keys are never removed from the selected-key set in any other way; they are not, in particular, removed as a side effect of selection operations. Keys may not be added directly to the selected-key set.</p>
</blockquote>
<p>对Java的NIO框架，所有处于就绪状态的key会一直在<code>Selector#selectedKey()</code>返回的集合中，除非你主动移除它。</p>
<h2 id="Rust-mio的作法"><a href="#Rust-mio的作法" class="headerlink" title="Rust mio的作法"></a>Rust mio的作法</h2><p>Rust对上边这个问题的处理，给用户提供了两种选择：edge-triggered 以及 level-triggered.<br>这个跟电路的相关知识类似。<br>下边是对相关文档的解要翻译：</p>
<blockquote>
<p>一个<code>Evented</code>在注册的时候可以选择请求的是edge-triggered事件，还是level-triggered的事件。<br>试想有下面的场景发生：</p>
<ol>
<li>通过<code>Poll</code>注册了一个<code>TcpStream</code></li>
<li>socket接收到了2kb数据</li>
<li>对<code>Poll::poll</code>的调用返回了token以及绑定在这个token上的socket，指示说这个socket处于读就绪状态。</li>
<li>从socket里读取了1kb数据</li>
<li>再次调用<code>Poll::poll</code></li>
</ol>
</blockquote>
<blockquote>
<p>如果在注册这个socket时要求的是edge-triggered event，那么当在第5步调用<code>Poll::poll</code>时可能会hang住，即使现在在socket的read buffer里有1kb数据。原因是edge-triggered模式只有当被监听的<code>Evented</code>有事件发生时才会投递事件。</p>
</blockquote>
<blockquote>
<p>当使用edger-triggered events时，必须对<code>Evented</code>进行处理，直接它返回<code>WouldBlock</code>。按句话说，在收到了指标说就绪状态的消息以后，你必须假设<code>Poll::poll</code>以后不会对这个token再返回消息，直到你对它的操作返回<code>WouldBlock</code>。</p>
</blockquote>
<blockquote>
<p>作为对比的是，当要求的是level-triggered通知时，只要相关的socket buffer有数据就会返回event。通常来说，当需要高性能时，就要避免使用level-triggered events.</p>
</blockquote>
<blockquote>
<p>Since even with edge-triggered events, multiple events can be generated upon receipt of multiple chunks of data, the caller has the option to set the oneshot flag. This tells Poll to disable the associated Evented after the event is returned from Poll::poll. The subsequent calls to Poll::poll will no longer include events for Evented handles that are disabled even if the readiness state changes. The handle can be re-enabled by calling reregister. When handles are disabled, internal resources used to monitor the handle are maintained until the handle is dropped or deregistered. This makes re-registering the handle a fast operation.</p>
</blockquote>
<blockquote>
<p>For example, in the following scenario:</p>
</blockquote>
<blockquote>
<ol>
<li>A TcpStream is registered with Poll.</li>
<li>The socket receives 2kb of data.</li>
<li>A call to Poll::poll returns the token associated with the socket indicating readable readiness.</li>
<li>2kb is read from the socket.</li>
<li>Another call to read is issued and WouldBlock is returned</li>
<li>The socket receives another 2kb of data.</li>
<li>Another call to Poll::poll is made.<br>Assuming the socket was registered with Poll with the edge and oneshot options, then the call to Poll::poll in step 7 would block. This is because, oneshot tells Poll to disable events for the socket after returning an event.</li>
</ol>
</blockquote>
<blockquote>
<p>In order to receive the event for the data received in step 6, the socket would need to be reregistered using reregister.</p>
</blockquote>
<p>这一段是说在注册到<code>Poll</code>的时候有个<code>oneshot</code>标识，当它被set以后，当相关的<code>Evented</code>的第一个event被返回以后，这个<code>Evented</code>的handle就被disable了，直到你调用<code>reregister</code>。由于在<code>Evented</code>的handle被disable以后，监控它所使用的内部资源没有被释放，所以这个re-register操作是一个很快的操作。</p>
<p>这个特性是Java所没有的。</p>
<h1 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h1><hr>
<p>只要按照下面的规范，<code>Poll</code>就提供了对所支持的所有平台都可用的接口。</p>
<h2 id="Spurious-Events"><a href="#Spurious-Events" class="headerlink" title="Spurious Events"></a>Spurious Events</h2><p>即使相关联的<code>Evented</code>handle没有真的就绪，<code>Poll::poll</code>也可能返回就绪事件。</p>
<p>如果操作失败，返回<code>WouldBlock</code>，那么调用者不应该把它当作一个错误，因该等待下一个就绪事件到来。</p>
<h2 id="Draining-readiness"><a href="#Draining-readiness" class="headerlink" title="Draining readiness"></a>Draining readiness</h2><p>当使用edge-triggered模式时，当收到一个就绪事件时，应该一直执行操作，直到<code>WouldBlock</code>被返回。</p>
<h2 id="Readiness-operations"><a href="#Readiness-operations" class="headerlink" title="Readiness operations"></a>Readiness operations</h2><p>只有<code>readable</code>和<code>writable</code>才是所有平台都支持的readiness operation。<br>所以即使注册了对<code>hup</code>和<code>error</code>的关注，当收到相关消息时，也只在通过实际的读写才能知道直正的情况。</p>
<h2 id="Registering-handles"><a href="#Registering-handles" class="headerlink" title="Registering handles"></a>Registering handles</h2><p>除非另外说明，应该假设实现了<code>Evented</code>的类型只有在被注册到<code>Poll</code>以后才可能就绪。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>关于reborrow的一个复杂的例子</title>
    <url>/2018/05/17/Rust_a_complex_example/</url>
    <content><![CDATA[<p>在查找关于Rust的reborrow的语法时，发现这么一篇文章<a href="https://bluss.github.io/rust/fun/2015/10/11/stuff-the-identity-function-does/">Stuff the Identity Function Does (in Rust)</a>。然后……看不懂，《Programming Rust》快看完了，这篇文章还是看不懂。<br>但是有很多不懂之处的文章，往往是最值得读的，因为它提供了一个线索，能把遗漏的知识串连起来，这是很难得的。</p>
<p>还好有Google, 一路搜索过来，大体也搞清楚了。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>文章里例子是这样的。有一个递归的数据结构，List:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    next: <span class="built_in">Option</span>&lt;<span class="built_in">Box</span>&lt;List&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写一个函数来遍历它</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> List &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">walk_the_list</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> current = <span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> current.next &#123;</span><br><span class="line">                <span class="literal">None</span> =&gt; <span class="keyword">return</span>,</span><br><span class="line">                <span class="literal">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> inner) =&gt; current = inner,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在Rust的<a href="https://play.rust-lang.org/?gist=613e13fd515bfca647ca&version=stable">playgroud</a>里测试一下。你会发现这段代码是通不过编译的。<br>问题在哪呢？</p>
<p>实际上这短短一段代码使用了很多隐晦的语法。</p>
<a id="more"></a>

<p>先来搞清楚它在做什么吧。</p>
<h2 id="match的是什么？"><a href="#match的是什么？" class="headerlink" title="match的是什么？"></a>match的是什么？</h2><p>在Rust的match表达式的分支里，是可以用<code>&amp;</code>来匹配reference的，比如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    v: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a = Foo&#123;v: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">match</span> &amp;a &#123;</span><br><span class="line">    &amp;Foo&#123;v&#125; =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, v + <span class="number">1</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">panic!</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(注： Rust 1.26里有了更简化的写法，见<a href="https://blog.rust-lang.org/2018/05/10/Rust-1.26.html">Announcing Rust 1.26</a>里的”Nicer match bindings<br>“)</p>
<p>但是在List的例子里， 不是这种情况， <code>current.next</code>并非一个reference。<br>所以，这个match表达式绝非在match一个reference，而是一个类型为<code>&lt;Option&lt;Box&lt;List&gt;&gt;</code>的值。</p>
<h2 id="ref-关键字"><a href="#ref-关键字" class="headerlink" title="ref 关键字"></a>ref 关键字</h2><p><code>some(ref mut inner)</code>这句以前貌似没见过。查了一下，发现这是在match表达式的分支里专用的一个语法。<br>可以参照这篇文章:<a href="http://xion.io/post/code/rust-patterns-ref.html">&amp; vs. ref in Rust patterns</a>。ref用于把一个原来需要move的地方，<br>改成只获取reference，从而避免move。在前边的代码里，实际上就是想避免对<code>current.next</code>的move。<br>实际上，由于<code>current</code>是一个reference，是不能通过它把<code>current.next</code>的值move out出去的。</p>
<p>比如, 下边的代码试着把<code>current.next</code> move给<code>d</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">walk_the_list</span></span>(<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> current = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">let</span> d = current.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会告诉你</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error[E0507]: cannot move out of borrowed content</span><br><span class="line">    --&gt; src&#x2F;main.rs:54:21</span><br><span class="line">     |</span><br><span class="line">  54 |             let d &#x3D; current.next;</span><br><span class="line">     |                     ^^^^^^^-----</span><br><span class="line">     |                     |</span><br><span class="line">     |                     cannot move out of borrowed content</span><br><span class="line">     |                     help: consider using a reference instead: &#96;&amp;current.next&#96;</span><br></pre></td></tr></table></figure>

<h1 id="错误信息和一些细节"><a href="#错误信息和一些细节" class="headerlink" title="错误信息和一些细节"></a>错误信息和一些细节</h1><p>如果你在试着编译最上边关于List的代码(也可以playgroud里执行run)，编译器会报两个error。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error[E0499]: cannot borrow &#96;current.next.0&#96; as mutable more than once at a time</span><br><span class="line">  --&gt; src&#x2F;main.rs:19:26</span><br><span class="line">   |</span><br><span class="line">19 |                     Some(ref mut inner) &#x3D;&gt; current &#x3D; inner,</span><br><span class="line">   |                          ^^^^^^^^^^^^^ mutable borrow starts here in previous iteration of loop</span><br><span class="line">...</span><br><span class="line">22 |         &#125;</span><br><span class="line">   |         - mutable borrow ends here</span><br><span class="line"></span><br><span class="line">error[E0506]: cannot assign to &#96;current&#96; because it is borrowed</span><br><span class="line">  --&gt; src&#x2F;main.rs:19:44</span><br><span class="line">   |</span><br><span class="line">19 |                     Some(ref mut inner) &#x3D;&gt; current &#x3D; inner,</span><br><span class="line">   |                          -------------     ^^^^^^^^^^^^^^^ assignment to borrowed &#96;current&#96; occurs here</span><br><span class="line">   |                          |</span><br><span class="line">   |                          borrow of &#96;current&#96; occurs here</span><br></pre></td></tr></table></figure>

<p>下边来搞清楚这两个错是怎么造成的。首先明确一下move和borrow这两个概念是否可用于reference，以及(如果可用的话)有什么作用。</p>
<h2 id="move和borrow"><a href="#move和borrow" class="headerlink" title="move和borrow"></a>move和borrow</h2><p>首先要搞清楚被move和borrow的是什么？<br>move会造成两个结果，一个是被move的值之前所在的内存变成了uninitialized状态，二是把之前的值拷贝到了move的目标内存。<br>所以，不仅像<code>let a = 1</code>里边的<code>a</code>这样的非reference的值可以被move, reference本身也可以被move。<br>像下边这个例子:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    v: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a = Foo&#123;v:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &amp;<span class="keyword">mut</span> a;</span><br><span class="line"><span class="keyword">let</span> c = b;</span><br><span class="line">b;</span><br></pre></td></tr></table></figure>
<p>编译器会说<code>use of moved value: b</code>，这是说<code>b</code>作为一个reference，它的值被move了，<code>b</code>成了未初始化状态，编译器会确保后边对<code>b</code>的使用(除非再给b赋值)会报错。</p>
<p>那么，reference可以被borrow吗？也是可以的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    v: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a = Foo&#123;v:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> b = &amp;<span class="keyword">mut</span> a;</span><br><span class="line"><span class="keyword">let</span> c = &amp;<span class="keyword">mut</span> b;</span><br><span class="line"><span class="keyword">let</span> d = &amp;<span class="keyword">mut</span> b;</span><br></pre></td></tr></table></figure>
<p>这一段编译器报的错是：</p>
<blockquote>
<p>cannot borrow <code>b</code> as mutable more than once at a time</p>
</blockquote>
<p>这就跟List的例子里编译器报的错很相似了。</p>
<blockquote>
<p> cannot borrow <code>current.next.0</code> as mutable more than once at a time</p>
</blockquote>
<h2 id="DerefMut"><a href="#DerefMut" class="headerlink" title="DerefMut"></a>DerefMut</h2><p>这里说同时不能<code>borrow current.next.0</code>超过一次。这个borrow是发生在<code>Some(ref mut inner)</code>这个branch里。但是<code>current.next.0</code>是个什么鬼？<br>而且<code>current = inner</code>这两边的类型不一致呀。 <code>inner</code>的类型是<code>&amp;mut Box&lt;List&gt;</code>， 而<code>current</code>的类型是<code>&amp;mut List</code>。<br>这里是有一个隐式的转换的，把<code>&amp;mut Box&lt;List&gt;</code>转成了<code>&amp;mut List</code>。这应该是<code>Box</code>实现了<code>Defmut</code>这个trait。实际上也是如此，Box实现了这个trait</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; DerefMut <span class="keyword">for</span> <span class="built_in">Box</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p>而DerefMut的定义是这样的</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">DerefMut</span></span>: Deref &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &amp;<span class="keyword">mut</span> Self::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，由于需一个<code>&amp;mut List</code>，但是目前只有<code>&amp;mut Box&lt;List&gt;</code>。<br>所以，Rust编译器会调用<code>Box::deref_mut(inner)</code>，返回对Box内的List的mutable reference。<br>好了，我们了解了<code>inner</code>的类型为<code>&amp;mut Box&lt;List&gt;</code>，它是对<code>next</code>为Some时其中的<code>Box&lt;List&gt;</code>的mutable reference。<br>它被赋值给<code>current</code>时发生了地<code>deref_mut</code>的调用(一个隐式类型转换)。</p>
<h1 id="current是怎么被borrow的？"><a href="#current是怎么被borrow的？" class="headerlink" title="current是怎么被borrow的？"></a><code>current</code>是怎么被borrow的？</h1><p>前边已知道的是，<code>current.next.0</code>是被borrow的状态。那么，为什么编译器同时也认为current也是在被borrow状态呢？<br>而且，在<code>z = &amp;mut current.next</code>的例子中，borrow的是<code>current.next</code>, 编译器也是报错说<code>current</code>被borrow了多次。</p>
<h2 id="auto-dereference"><a href="#auto-dereference" class="headerlink" title="auto-dereference"></a>auto-dereference</h2><p><code>current.next</code>很明显是说<code>List</code>里的叫<code>next</code>的field。但是<code>current</code>是一个reference呀，它没有next这个field呀。这里是用的Rust的auto-dereference<br>语法，实际上是调用的<code>(*current).next</code>。但是，还不只这么简单，看下边的例子。</p>
<h2 id="通过current-next进行的reborrow"><a href="#通过current-next进行的reborrow" class="headerlink" title="通过current.next进行的reborrow"></a>通过current.next进行的reborrow</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">walk_the_list</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> current = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">let</span> d = &amp;<span class="keyword">mut</span> current.next;</span><br><span class="line">    <span class="keyword">let</span> z = &amp;<span class="keyword">mut</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里编译器会报错说：</p>
<blockquote>
<p>error[E0499]: cannot borrow <code>current</code> as mutable more than once at a time<br>   –&gt; src/main.rs:37:26<br>    |<br> 36 |             let d = &amp;mut current.next;<br>    |                          ———— first mutable borrow occurs here<br> 37 |             let z = &amp;mut current;<br>    |                          ^^^^^^^ second mutable borrow occurs here<br> 38 |         }<br>    |         - first borrow ends here</p>
</blockquote>
<p>它不会允许我们再次borrow <code>current</code>这个reference了，因为我们通过<code>&amp;mut current.next</code>隐式地使得<code>current</code>被borrow了。<br>注意，这是使得<code>current</code>这个reference被borrow了，而非<code>current</code>指向的值被borrow了。</p>
<p>不过，事实上<code>*current</code>也被borrow了。看这个例子</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">walk_the_list</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, other: List) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> current = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">let</span> b = &amp;<span class="keyword">mut</span> current.next;</span><br><span class="line">    *current = other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会说:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error[E0506]: cannot assign to &#96;*current&#96; because it is borrowed</span><br><span class="line">  --&gt; src&#x2F;main.rs:47:13</span><br><span class="line">   |</span><br><span class="line">46 |             let d &#x3D; &amp;mut current.next;</span><br><span class="line">   |                          ------------ borrow of &#96;*current&#96; occurs here</span><br><span class="line">47 |             *current &#x3D; other;</span><br><span class="line">   |             ^^^^^^^^^^^^^^^^ assignment to borrowed &#96;*current&#96; occurs here</span><br></pre></td></tr></table></figure>

<p>当然，<code>current</code>就是<code>*current</code>的mutable reference。但是，编译器的这句话指向的是在<code>let d = &amp;mut current.next</code>时， <code>*current</code>被borrow的。<br>这句话应该这么看，如果只有<code>current</code>这唯一的一个mutable reference，那么<code>*current = other</code>就是合理的。但是，<code>let d = &amp;mut current.next</code>产生<br>了另一个我们拿不到的mutable reference，可以把<code>&amp;mut a.b</code>可以认为实际上执行的是<code>&amp;mut (*a).b</code>, 这样<code>*a</code>就被borrow了，这样在<code>d</code>的生命周期里，<code>current</code><br>就不可用了。</p>
<p>也就是说，如果我们通过<code>let c = &amp;mut a.b</code>的形式来搞到一个<code>b</code>的mutable reference时。编译器会使得<code>a</code>处于mutable borrowed状态, 无论<code>a</code>是不是reference。<br>而且假如b的owner path的更上游也会处于这个状态。</p>
<h2 id="ownship-path"><a href="#ownship-path" class="headerlink" title="ownship path"></a>ownship path</h2><p>关于reference的 ‘shared vs mutation’,《Programming Rust》里这么说：</p>
<blockquote>
<p>Each kind of reference affects what we can do with the values along the owning path to the reference, and the values reachable from the reference.<br>Note that in both cases, the path of ownership leading to the referent cannot be changed for the references’s lifetime.For a shared borrow, the path is readonly; for a mutable borrow, it’s completely inaccessible. So there’s no way for the program to do anything that will invalidate the reference.</p>
</blockquote>
<p>Rust这样做的目的，就是使刚才获得的mutable reference:<code>c</code>不会成为dangling pointer。当我们获取一个mutable reference时，例如<code>inner</code>, 它是对<code>current.next.0</code>的mutable borrow， 那么 the path of ownship leading to <code>current.next.0</code> 在<code>inner</code>的lifetime中都是’completely inaccessible’的。<br>这里 <em>inaccessible</em> 并非是说在以后的代码里就不能用<code>current</code>这个变量了，而是说不通单独使用它，例如<code>let x = current</code>。<br>而 <em>the path of ownship leading to the referent</em> 是说<code>inner</code>所指向的值，也就是<code>current.next.0</code>的owner, 以及owner的owner … 。<br>由于当一个值有了mutable reference期间，只能通过这个reference使用它，所以可以认为mutable reference在这个ownship path上跟它的referent是处于同一位置。<br>所以<code>current</code>也就成了 <strong>inaccessible</strong> 的了。</p>
<h1 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h1><p>现在还是没有搞清楚为什么这个loop block会导致错误。</p>
<p>可以参见<a href="https://www.reddit.com/r/rust/comments/6h0h0b/borrowing_in_loops/">borrowing in loops</a>,</p>
<p>首先，假如原代码改成</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">walk_the_list</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> current = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> current.next &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span>,</span><br><span class="line">            <span class="literal">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> inner) =&gt; (),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以通过编译了。显然，是<code>current = inner</code>这一句导致了在loop的一次迭代结束后，之前的<code>current.next.0</code>仍然处于mutable borrowed状态。<br>而去掉<code>current = inner</code>以后，<code>inner</code>作为对<code>current.next.0</code>的borrow的生命周期结束了，同时使得对<code>current</code>的隐式的borrow结束了。<br>比如，下边这段代码会报错:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">walk_the_list</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> current = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">match</span> current.next &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="keyword">return</span>,</span><br><span class="line">        <span class="literal">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> inner) =&gt; current = inner,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ref_current = &amp;<span class="keyword">mut</span> current.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器说</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error[E0499]: cannot borrow &#96;current.next&#96; as mutable more than once at a time</span><br><span class="line">  --&gt; src&#x2F;main.rs:65:36</span><br><span class="line">   |</span><br><span class="line">63 |                 Some(ref mut inner) &#x3D;&gt; current &#x3D; inner,</span><br><span class="line">   |                      ------------- first mutable borrow occurs here</span><br><span class="line">64 |             &#125;</span><br><span class="line">65 |             let ref_current &#x3D; &amp;mut current.next;</span><br><span class="line">   |                                    ^^^^^^^^^^^^ second mutable borrow occurs here</span><br><span class="line">66 |         &#125;</span><br><span class="line">   |         - first borrow ends here</span><br></pre></td></tr></table></figure>
<p>虽然<code>current = inner</code>这句不能通过编译，但是编译器仍然认为<code>inner</code>的生命周期在match结束后没有结束，这就使得<code>current.next</code>仍然处于被borrow的状态。<br>在原来的例子里，这就意味着<code>current.next.0</code>仍然处于被borrow的状态。同样由于<code>current = inner</code>不能执行，编译器认为两次迭代borrow的是同一个<br><code>current.next.0</code>。</p>
<h1 id="你需要的只是move"><a href="#你需要的只是move" class="headerlink" title="你需要的只是move"></a>你需要的只是move</h1><p>那么怎么可以让它摆脱这种状态呢？编译器一直报怨的是多次borrow了<code>current</code>这个reference它的<strong>值</strong>。<br>所以只要在match前把它move出来就行了。因为当<code>current</code>再次被赋值时，就可以认为对它的borrow跟对上一个<code>current</code>的borrow完全没关系了，只不过被borrow的值的名字都叫<code>current</code>而已。<br>这也是<strong>move</strong>这个语法的本意，一个变量的值被move走之后，它就成了未初始化状态，就跟之前的值和之前的ownership path啥的没有关系了。<br>当它再被赋值后，它的属性就继承了对刚才被赋的值的属性，跟它的前世也没啥关系。</p>
<p>下边我们用上作者提到的<code>id</code>函数</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">id</span></span>&lt;T&gt;(x: T) -&gt; T &#123; x &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">walk_the_list</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> current = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">match</span> id(current).next &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="keyword">return</span>,</span><br><span class="line">        <span class="literal">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> inner) =&gt; current = inner,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> current.next &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="keyword">return</span>,</span><br><span class="line">        <span class="literal">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> inner) =&gt; current = inner,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次编译器就不会再报多次borrow的错误了。因为id函数把current的值move给了函数参数。</p>
<p>这里要注意<code>id</code>的实现细节，它是一个generic function，如果参数的类型不是<code>T</code>，而是<code>&amp;mut List</code>，即把<code>id</code>改成：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">id</span></span>(x: &amp;<span class="keyword">mut</span> List) -&gt; &amp;<span class="keyword">mut</span> List &#123; x &#125;</span><br></pre></td></tr></table></figure>
<p>就还会有同样的错误。<br>这就牵扯到了一个更隐晦的问题，就是Rust什么时候会move，什么时候会reborrow。<br>在<a href="https://www.reddit.com/r/rust/comments/46qwjv/why_can_i_use_an_mut_reference_twice/">Why can I use an &amp;mut reference twice?</a><br>里有所提及。其中的一个说法是，<code>&amp;Mut List</code>并非current的全部类型，因为所有的reference的lifetime是它的类型的一部分，所以，当把<code>current</code>传给修改后的id时，<br>编译器会使得reborrow，而非move。但是使用泛型，就可以完全匹配<code>current</code>的类型。</p>
<p>事实上，还有别的方法可以通过编译，而且不用id函数，例如:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">walk_the_list</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> current = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> tmp = current;</span><br><span class="line">        <span class="keyword">match</span> tmp.next &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span>,</span><br><span class="line">            <span class="literal">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> inner) =&gt; current = inner,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里显式地把<code>current</code>给 move到了<code>z</code>，使得后边的<code>current = innner</code>可以成功。编译器就可以进行同样的推导。</p>
<p>而且，正如原文中提到的，可以用Rust的一种特殊的语法 – <code>{}</code>, 来进行move。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">walk_the_list_with_braces</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> current = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> &#123;current&#125;.next &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span>,</span><br><span class="line">            <span class="literal">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> inner) =&gt; current = inner,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在想一下这段代码的作用，它只是walk the list， 在方法执行完以后，这个List还跟原来一样。所以，如果只是实现同样的功能，下边的代码就够了：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">walk_the_list</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> current = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> current.next &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span>,</span><br><span class="line">            <span class="literal">Some</span>(<span class="keyword">ref</span> inner) =&gt; current = inner,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原文在最后提了一下consume这个list的方法</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> List &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">walk_the_list_with_braces</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> current = <span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> &#123;current&#125;.next &#123;</span><br><span class="line">                <span class="literal">None</span> =&gt; <span class="keyword">return</span>,</span><br><span class="line">                <span class="literal">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> inner) =&gt; current = inner,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">consume_the_list_with_braces</span></span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        &#123;<span class="keyword">self</span>&#125;.walk_the_list_with_braces();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里在<code>consume_the_list_with_braes</code>里<code>{self}</code>貌似没有必要，但是如果你去掉<code>{}</code>，编译器会说：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error[E0596]: cannot borrow immutable argument &#96;self&#96; as mutable</span><br><span class="line">  --&gt; src&#x2F;main.rs:45:13</span><br><span class="line">   |</span><br><span class="line">44 |         fn consume_the_list_with_braces(self) &#123;</span><br><span class="line">   |                                         ---- consider changing this to &#96;mut self&#96;</span><br><span class="line">45 |             self.walk_the_list_with_braces();</span><br><span class="line">   |             ^^^^ cannot borrow mutably</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br></pre></td></tr></table></figure>
<p>由于是<code>self</code>而非<code>mut self</code>，<code>self</code>是一个immutable binding, 是不能对它进行 mutable borrow的。<br>但是通过<code>{}</code>，<code>self</code>的值被move出来到了一个临时的值中，没有对它的任何immutable binding，这样就绕过了immutable binding的限制。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>spark里的filter和projection pushdown</title>
    <url>/2020/08/16/pushdown/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>predicate pushdown也叫filter pushdown。</p>
<p>所以，有两种pushdown。</p>
<ul>
<li>projection pushdown， 用于<code>select</code> 的pushdown</li>
<li>filter pushdown, 用于<code>filter</code>的pushdown</li>
</ul>
<p>先来明确一下这俩在干嘛。</p>
<h2 id="1-1-projection-pushdown"><a href="#1-1-projection-pushdown" class="headerlink" title="1.1 projection pushdown"></a>1.1 projection pushdown</h2><blockquote>
<p>Projection Pushdown minimizes data transfer between MapR Database and the Apache Spark engine by omitting unnecessary fields from table scans. It is especially beneficial when a table contains many columns.</p>
</blockquote>
<p>projection pushdown通过在table scan过程中忽略不需要的列来减少从数据源读取的数据量。把projection下堆到数据源处。</p>
<p>当使用<code>select</code>的时候，会进行projection pushdown，比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line">            </span><br><span class="line">df = spark_session.loadFromMapRDB(<span class="string">"/tmp/user_profiles"</span>)</span><br><span class="line">df.select(<span class="string">"_id"</span>, <span class="string">"first_name"</span>, <span class="string">"last_name"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="1-2-filter-pushdown"><a href="#1-2-filter-pushdown" class="headerlink" title="1.2 filter pushdown"></a>1.2 filter pushdown</h2><p>把筛选行的filter下推到数据源处。</p>
<p>也是会减少从数据源传输到spark engine的数据量，但减少的单位是“行”，而projection pushdown减少的单位是“列”。</p>
<p>比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line">            </span><br><span class="line">df = spark_session.loadFromMapRDB(<span class="string">"/tmp/user_profiles"</span>)</span><br><span class="line">df.filter(<span class="string">"first_name = 'Bill'"</span>)</span><br></pre></td></tr></table></figure>

<p>支持以下filter的pushdown:</p>
<ul>
<li><code>=</code> 和<code>!=</code></li>
<li><code>&lt;</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li>
<li><code>IN</code></li>
<li><code>LIKE</code></li>
<li><code>AND</code>， <code>OR</code></li>
<li><code>NOT</code></li>
</ul>
<h2 id="1-3-限制"><a href="#1-3-限制" class="headerlink" title="1.3 限制"></a>1.3 限制</h2><p>filter pushdown不支持复杂类型：array, map, struct, 比如</p>
<p>scala</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.filter($<span class="string">"address.city"</span> === <span class="string">"Milpitas"</span>)</span><br></pre></td></tr></table></figure>

<p>java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.filter(col(&quot;address.city&quot;).equalTo(&quot;Milpitas&quot;));</span><br></pre></td></tr></table></figure>



<p>projection pushdown也不支持这些复杂类型， 比如</p>
<p>scala</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ds.select($&quot;hobbies&quot; (0))</span><br></pre></td></tr></table></figure>

<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">df.select(col(<span class="string">"hobbies"</span>).getItem(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>但是spark3.0进行了一些改进。</p>
<h1 id="2-databricks关于FilterPushdown的例子"><a href="#2-databricks关于FilterPushdown的例子" class="headerlink" title="2. databricks关于FilterPushdown的例子"></a>2. databricks关于FilterPushdown的例子</h1><p>databricks有一些例子<a href="https://databricks-prod-cloudfront.cloud.databricks.com/public/4027ec902e239c93eaaa8714f173bcfc/3741049972324885/4201913720573284/4413065072037724/latest.html">How logical plan optimizations work in Catalyst</a></p>
<h2 id="2-1-more-interesting-example"><a href="#2-1-more-interesting-example" class="headerlink" title="2.1 more interesting example"></a>2.1 more interesting example</h2><p>创建两个DataFrame</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> items = <span class="type">Seq</span>((<span class="number">0</span>, <span class="string">"Macbook Pro"</span>, <span class="number">1999.0</span>), (<span class="number">1</span>, <span class="string">"Macbook Air"</span>, <span class="number">1500.0</span>), (<span class="number">2</span>, <span class="string">"iPad Air"</span>, <span class="number">1200.0</span>)).toDF(<span class="string">"id"</span>, <span class="string">"name"</span>, <span class="string">"price"</span>)</span><br><span class="line"><span class="keyword">val</span> orders = <span class="type">Seq</span>((<span class="number">100</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">101</span>, <span class="number">2</span>, <span class="number">3</span>)).toDF(<span class="string">"id"</span>, <span class="string">"itemid"</span>, <span class="string">"count"</span>)</span><br><span class="line"></span><br><span class="line">items.createOrReplaceTempView(<span class="string">"item"</span>)</span><br><span class="line">orders.createOrReplaceTempView(<span class="string">"order"</span>)</span><br></pre></td></tr></table></figure>

<p>然后搞一个简单的join以及filter</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order.id, item.name, item.price, order.count</span><br><span class="line"><span class="keyword">FROM</span> item</span><br><span class="line"><span class="keyword">JOIN</span> <span class="keyword">order</span> </span><br><span class="line"><span class="keyword">WHERE</span> item.id = order.itemid <span class="keyword">and</span> item.price &lt; <span class="number">1400</span> <span class="keyword">and</span> order.count &gt; <span class="number">2</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-1-analyzed-plan"><a href="#2-1-1-analyzed-plan" class="headerlink" title="2.1.1 analyzed plan"></a>2.1.1 analyzed plan</h3><p>然后看<strong>analyzed plan</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> analyzedPlan = sql(<span class="string">"SELECT order.id, item.name, item.price, order.count FROM item JOIN order WHERE item.id = order.itemid and item.price &lt; 1400 and order.count &gt; 2 - 1"</span>).queryExecution.analyzed</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">analyzedPlan: org.apache.spark.sql.catalyst.plans.logical.LogicalPlan &#x3D; </span><br><span class="line">Project [id#15942, name#15929, price#15930, count#15944]</span><br><span class="line">+- Filter (((id#15928 &#x3D; itemid#15943) &amp;&amp; (price#15930 &lt; cast(1400 as double))) &amp;&amp; (count#15944 &gt; (2 - 1)))</span><br><span class="line">   +- Join Inner</span><br><span class="line">      :- SubqueryAlias item</span><br><span class="line">      :  +- Project [_1#15924 AS id#15928, _2#15925 AS name#15929, _3#15926 AS price#15930]</span><br><span class="line">      :     +- LocalRelation [_1#15924, _2#15925, _3#15926]</span><br><span class="line">      +- SubqueryAlias order</span><br><span class="line">         +- Project [_1#15938 AS id#15942, _2#15939 AS itemid#15943, _3#15940 AS count#15944]</span><br><span class="line">            +- LocalRelation [_1#15938, _2#15939, _3#15940]</span><br></pre></td></tr></table></figure>

<p>这里边<code>Filter</code>是<code>Join</code>的父节点，意味着filter条件里的<code>item.price &lt; 1400 and order.count &gt; 2 - 1</code>是在join之后才被执行。</p>
<h3 id="2-1-2-optimized-plan"><a href="#2-1-2-optimized-plan" class="headerlink" title="2.1.2 optimized plan"></a>2.1.2 optimized plan</h3><p>看optimized plan</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Apply Spark SQL optimizations</span></span><br><span class="line"><span class="keyword">val</span> optimizedPlan = <span class="type">SimpleTestOptimizer</span>.execute(analyzedPlan)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optimizedPlan: org.apache.spark.sql.catalyst.plans.logical.LogicalPlan &#x3D; </span><br><span class="line">Project [id#15942, name#15929, price#15930, count#15944]</span><br><span class="line">+- Join Inner, (id#15928 &#x3D; itemid#15943)</span><br><span class="line">   :- Project [_1#15924 AS id#15928, _2#15925 AS name#15929, _3#15926 AS price#15930]</span><br><span class="line">   :  +- Filter (_3#15926 &lt; 1400.0)</span><br><span class="line">   :     +- LocalRelation [_1#15924, _2#15925, _3#15926]</span><br><span class="line">   +- Project [_1#15938 AS id#15942, _2#15939 AS itemid#15943, _3#15940 AS count#15944]</span><br><span class="line">      +- Filter (_3#15940 &gt; 1)</span><br><span class="line">         +- LocalRelation [_1#15938, _2#15939, _3#15940]</span><br></pre></td></tr></table></figure>

<p>这里可以看到几点变化：</p>
<ol>
<li>Filter被下推，直接作用于<code>LocalRelation</code>。 适用的规则为<code>PushDownPredicate</code></li>
<li><code>2 - 1</code> 被替换成了<code>1</code>。 适用的规则为<code>ConstantFolding</code></li>
<li><code>SubqueryAlia</code>节点被直接优化掉了</li>
<li><code>cast(1400 as double)</code>被换成了<code>1400.0</code></li>
</ol>
<h3 id="2-1-3-Write-rules-for-logical-plan"><a href="#2-1-3-Write-rules-for-logical-plan" class="headerlink" title="2.1.3 Write rules for logical plan"></a>2.1.3 Write rules for logical plan</h3><blockquote>
<p>Catalyst operates with logical plans and expressions, even attribute is an expression. Below are some examples how to convert one expression into another another using rules. Each logical plan is essentially a bunch of <code>QueryPlan[LogicalPlan]</code> instances and <code>Expression</code> expressions. Some examples of logical plans are <code>Project</code>, <code>Generate</code>, <code>Filter</code>, etc.</p>
</blockquote>
<p>翻译一下：</p>
<blockquote>
<p> Catalyst操作的对象是_logical plans_以及_expressions_， 即使是attribute也是一种expression。下边是一些使用规则(rule)将一个表达式转换成另一个的例子。每个logical plan本质是就是一组<code>QueryPlan[LogicalPlan]</code>实例和<code>Expression</code>表达式。logical plan的例子包括<code>Project</code>, <code>Generate</code>, <code>Filter</code>等。</p>
</blockquote>
<p>这里有一些东东不大明白：</p>
<ol>
<li><code>QueryPlan[LogicalPlan]</code>是个什么东东？</li>
<li><strong>plan</strong>这个概念和<strong>expression</strong>有啥区别？</li>
</ol>
<p>继续往下看</p>
<h4 id="2-1-3-1-expression的转换"><a href="#2-1-3-1-expression的转换" class="headerlink" title="2.1.3.1 expression的转换"></a>2.1.3.1 expression的转换</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Simple expression transform</span></span><br><span class="line"><span class="keyword">val</span> add = <span class="type">Add</span>(<span class="type">Literal</span>(<span class="number">2</span>), <span class="type">Literal</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> subtract = add transform &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Add</span>(left, right) =&gt; <span class="type">Subtract</span>(left, right)</span><br><span class="line">&#125;</span><br><span class="line">add: org.apache.spark.sql.catalyst.expressions.<span class="type">Add</span> = (<span class="number">2</span> + <span class="number">3</span>)</span><br><span class="line">subtract: org.apache.spark.sql.catalyst.expressions.<span class="type">Expression</span> = (<span class="number">2</span> - <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Analyzer is built from rules, each rule is essentially one operation that takes logical plan and returns logical plan with very minimal change, hopefully better change. See example below:</p>
</blockquote>
<p>是说rule就是一个operator，输入和输出都是logical plan， 不过这俩logical plan会有些许不同，目的是进行一些优化。</p>
<p><code>transform</code>方法的定义为</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>(rule: <span class="type">PartialFunction</span>[<span class="type">BaseType</span>, <span class="type">BaseType</span>]): <span class="type">BaseType</span> = &#123;</span><br><span class="line">  transformDown(rule)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Add</span>(left, right) =&gt; <span class="type">Subtract</span>(left, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是一个rule。<code>add</code>和<code>subtract</code>就是两个<code>Expression</code>。这里通过一个自己实现的rule，将<code>Add</code>表达式转成了<code>Subtract</code>表达式。</p>
<h4 id="2-1-3-2-TreeNode"><a href="#2-1-3-2-TreeNode" class="headerlink" title="2.1.3.2 TreeNode"></a>2.1.3.2 TreeNode</h4><p><code>transform</code>是<code>Add</code>继承自<code>TreeNode</code>的方法。</p>
<p>这里<code>TreeNode</code>的类型参数有点绕。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class TreeNode[BaseType &lt;: TreeNode[BaseType]] extends Product &#123;</span><br><span class="line">&#x2F;&#x2F; scalastyle:on</span><br><span class="line">  self: BaseType &#x3D;&gt;</span><br></pre></td></tr></table></figure>

<p>在这里要注意两点</p>
<ol>
<li><p><code>TreeNode</code>是一个<strong>invariant</strong>  class，不是协变类，也不是逆变类。</p>
</li>
<li><p><code>TreeNode</code>要求其自身是一个<code>BaseType</code>。也就是说， <code>BaseType</code>实际上就是指它自己或它的子类。这样在定义方法的时候就可以用到这个限制。比如，<code>TreeNode</code>的foreach方法这么定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Runs the given function on this node and then recursively on [[children]].</span><br><span class="line"> * @param f the function to be applied to each node in the tree.</span><br><span class="line"> *&#x2F;</span><br><span class="line">def foreach(f: BaseType &#x3D;&gt; Unit): Unit &#x3D; &#123;</span><br><span class="line">  f(this)</span><br><span class="line">  children.foreach(_.foreach(f))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里之所以可以<code>f(this)</code>, 就是因为<code>self: BaseType =&gt;</code>这个自身类型限制。如果去掉自身类型的限制，那么就<code>f(this)</code>就不合语法了。</p>
</li>
</ol>
<p>实际上它的直接子类都这样类义的：</p>
<p><strong>Expression</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> <span class="keyword">extends</span> <span class="title">TreeNode</span>[<span class="type">Expression</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>Block</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Block</span> <span class="keyword">extends</span> <span class="title">TreeNode</span>[<span class="type">Block</span>] <span class="keyword">with</span> <span class="title">JavaCode</span></span></span><br></pre></td></tr></table></figure>

<p><strong>QueryPlan</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryPlan</span>[<span class="type">PlanType</span> &lt;: <span class="type">QueryPlan</span>[<span class="type">PlanType</span>]] <span class="keyword">extends</span> <span class="title">TreeNode</span>[<span class="type">PlanType</span>] </span>&#123;</span><br><span class="line">  self: <span class="type">PlanType</span> =&gt;</span><br></pre></td></tr></table></figure>

<p>这样写的话，<code>Expression</code>继承的<code>TreeNode</code>的方法，如果参数类型是<code>BaseType</code>，那么就只能传进去<code>Expression</code>的子类，而不能传进去<code>Block</code>的子类。</p>
<p>这样是不可以的</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> plan3 = add transform &#123;</span><br><span class="line">    <span class="keyword">case</span> foo: <span class="type">LogicalPlan</span> =&gt; foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就会报错</p>
<blockquote>
<p>pattern type is incompatible with expected type;<br>found   : org.apache.spark.sql.catalyst.plans.logical.LogicalPlan<br>required: org.apache.spark.sql.catalyst.expressions.Expression<br>case foo: LogicalPlan =&gt; foo</p>
</blockquote>
<p>也就是说add接受的transform实际上的类型要求是<code>PartialFunction[Expression, Expression]</code> (这里要注意PartitalFunction的型变)。</p>
<p>这么搞，有利于递归调用rule的时候避免错误匹配，比如一个用于<code>Expression</code>的规则被误用到了一个<code>LogicalPlan</code>，就要出问题了。</p>
<h3 id="2-1-4-Existing-filter-optimizations"><a href="#2-1-4-Existing-filter-optimizations" class="headerlink" title="2.1.4 Existing filter optimizations"></a>2.1.4 Existing filter optimizations</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> logicalPlan = <span class="type">LocalRelation</span>(int(<span class="symbol">'a</span>), str(<span class="symbol">'b</span>)).</span><br><span class="line">  select(<span class="symbol">'a</span>).</span><br><span class="line">  where(<span class="type">GreaterThan</span>(<span class="type">Add</span>(<span class="symbol">'a</span>, <span class="type">Literal</span>(<span class="number">1</span>)), <span class="type">Literal</span>(<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> analyzedPlan = logicalPlan.analyze</span><br><span class="line"><span class="keyword">val</span> optimizedPlan = <span class="type">SimpleTestOptimizer</span>.execute(analyzedPlan)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logicalPlan: org.apache.spark.sql.catalyst.plans.logical.LogicalPlan &#x3D; </span><br><span class="line">&#39;Filter ((&#39;a + 1) &gt; 2)</span><br><span class="line">+- &#39;Project [&#39;a]</span><br><span class="line">   +- LocalRelation &lt;empty&gt;, [a#21651, b#21652]</span><br><span class="line"></span><br><span class="line">analyzedPlan: org.apache.spark.sql.catalyst.plans.logical.LogicalPlan &#x3D; </span><br><span class="line">Filter ((a#21651 + 1) &gt; 2)</span><br><span class="line">+- Project [a#21651]</span><br><span class="line">   +- LocalRelation &lt;empty&gt;, [a#21651, b#21652]</span><br><span class="line"></span><br><span class="line">optimizedPlan: org.apache.spark.sql.catalyst.plans.logical.LogicalPlan &#x3D; </span><br><span class="line">Project [a#21651]</span><br><span class="line">+- Filter (isnotnull(a#21651) &amp;&amp; ((a#21651 + 1) &gt; 2))</span><br><span class="line">   +- LocalRelation &lt;empty&gt;, [a#21651, b#21652]</span><br></pre></td></tr></table></figure>

<p>这里可以看到<code>((a#21651 + 1) &gt; 2))</code>并非最优的形式。所以，下面自己创建一个rule来解析这个表达式。</p>
<h3 id="2-1-5-Optimize-filter-folding"><a href="#2-1-5-Optimize-filter-folding" class="headerlink" title="2.1.5 Optimize filter folding"></a>2.1.5 Optimize filter folding</h3><p>创建一个<code>Rule</code>，叫做<code>SimpleFilterFolding</code>。代码为</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Let's call our rule SimpleFilterFolding</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SimpleFilterFolding</span> <span class="keyword">extends</span> <span class="title">Rule</span>[<span class="type">LogicalPlan</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(plan: <span class="type">LogicalPlan</span>): <span class="type">LogicalPlan</span> = plan transform &#123;</span><br><span class="line">    <span class="comment">// We take logical plan and only apply our rule when we encounter filter with a simple `add` condition</span></span><br><span class="line">    <span class="keyword">case</span> filter @ <span class="type">Filter</span>(condition, _) =&gt; filter transformExpressionsUp &#123;</span><br><span class="line">      <span class="comment">// What we need to do is replacing our filter where `expr` is greater than right side - literal</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">GreaterThan</span>(<span class="type">Add</span>(expr, literal: <span class="type">Literal</span>), right) =&gt; </span><br><span class="line">        <span class="type">GreaterThan</span>(expr, <span class="type">Subtract</span>(right, literal))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后把这个rule注册到我们的optimizer中。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SimpleOptimizer</span> <span class="keyword">extends</span> <span class="title">RuleExecutor</span>[<span class="type">LogicalPlan</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> batches = <span class="type">Batch</span>(<span class="string">"Filter folding"</span>, <span class="type">Once</span>, </span><br><span class="line">    <span class="type">SimpleFilterFolding</span>) :: <span class="type">Nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We take analyzed plan and run through Optimizer object</span></span><br><span class="line"><span class="keyword">val</span> optimizedPlan = <span class="type">SimpleOptimizer</span>.execute(analyzedPlan)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defined module SimpleOptimizer</span><br><span class="line">optimizedPlan: org.apache.spark.sql.catalyst.plans.logical.LogicalPlan &#x3D; </span><br><span class="line">Filter (a#21651 &gt; (2 - 1))</span><br><span class="line">+- Project [a#21651]</span><br><span class="line">   +- LocalRelation &lt;empty&gt;, [a#21651, b#21652]</span><br></pre></td></tr></table></figure>

<p>这里<code>(2 - 1)</code>并没有被优化掉。但是已有rule可以做这件事，就是叫做<code>ConstantFolding</code>的rule，现在把它跟我们的rule一起使用。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SimpleOptimizer</span> <span class="keyword">extends</span> <span class="title">RuleExecutor</span>[<span class="type">LogicalPlan</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> batches = <span class="type">Batch</span>(<span class="string">"Filter folding"</span>, <span class="type">Once</span>, </span><br><span class="line">    <span class="type">SimpleFilterFolding</span>, <span class="type">ConstantFolding</span>) :: <span class="type">Nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We take analyzed plan and run through Optimizer object</span></span><br><span class="line"><span class="keyword">val</span> optimizedPlan = <span class="type">SimpleOptimizer</span>.execute(analyzedPlan)</span><br></pre></td></tr></table></figure>

<p>这样结果就对了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defined module SimpleOptimizer</span><br><span class="line">optimizedPlan: org.apache.spark.sql.catalyst.plans.logical.LogicalPlan &#x3D; </span><br><span class="line">Filter (a#21651 &gt; 1)</span><br><span class="line">+- Project [a#21651]</span><br><span class="line">   +- LocalRelation &lt;empty&gt;, [a#21651, b#21652]</span><br></pre></td></tr></table></figure>



<p>Spark 3.0的在filter pushdown方面有了进步，这个下个blog再研究。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://docs.datafabric.hpe.com/61/Spark/ProjectionFilterPushdownDataFramesDatasets.html">Projection and Filter Pushdown with Apache Spark DataFrames and Datasets</a></li>
<li><a href="https://databricks-prod-cloudfront.cloud.databricks.com/public/4027ec902e239c93eaaa8714f173bcfc/3741049972324885/4201913720573284/4413065072037724/latest.html">Filter pushdown</a></li>
</ul>
]]></content>
      <categories>
        <category>spark</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
</search>
